#!/bin/bash
#
# ** nextcloud_backups_aws_s3 **
# Utility to make backups of Nextcloud and store them in an S3 bucket
#
# √Ålvaro Castellano Vela - https://github.com/a-castellano

# Option variables
ENABLE_LOG=false # by default this script write logs via syslog

# Default values
NEXTCLOUD_PATH='/var/www/nextcloud'
NEXTCLOUD_USERS='ALL'
CONFIG_FOLDER='~/.config/nexcloud_backups_aws_s3'

# Nextcloud variables
NEXTCLOUD_CONFIG_ROUTE='/config/config.php'

# Log variables
LOGGET_TAG="nextcloud_backups_aws_s3"
LOGGER="$(which logger) -t $LOGGET_TAG"

# Misc
WHICH=$(which which)
ECHO=$($WHICH echo)
TR=$($WHICH tr)
RM=$($WHICH rm)
SED=$($WHICH sed)
CAT=$($WHICH cat)
PRINTF=$($WHICH printf)
CUT=$($WHICH cut)
TOUCH=$($WHICH touch)

# Functions

function usage {
$CAT << EOF
Usage: nexcloud_backups_aws_s3 [OPTIONS] [ARGUMENTS]
Make backups of Nextcloud and store them in an S3 bucket.

For avoiding user to wirte thier secret credentials in the command line
this script will look for config variables in ~/.config/nexcloud_backups_aws_s3
folder. In that folder users can place a files or files contining their
database credentials, S3 access keys, etc.

Arguments:

    --s3-access-key=YOUR_S3_ACCES_KEY
    --s3-secret-key=YOUR_S3_SECRET_KEY
    --database-name=DATABASE_NAME
    --database-user=DATABASE_USER_NAME
    --database-passwd=DATABASE_PASSWORD
    --database-host=DATABSE_HOST           (IP or domain)
    --database-port=PORT                   By default it will be 3306.
    --nextcloud-path=PATH                  Nexcloud path is /var/www/nexcloud
                                             by default.
    --nextcloud-users="user1,user2"        By default this script will backup
                                             all users folders.
    --test="argument,argument2"            Prints valuw of selected arguments.

    Nexcloud users and test varibales can be separated by spaces

Options:

    -h                                    Prints this text.
    -u --usage                            Prints this text.
    -v --verbose                          Enables verbose output.
    -s --silent                           Disable any output in STDOUT.
    -l --enable-log                       By default this scripts uses syslog
                                            for logging with this option enables
                                            it also write logs in the file
                                            spefied in "--logfile" option.
    --log-file=FILE                       In addition to write logs in syslog the
                                            logs will be written in the file provided.
    --exclude-database                    Exclude Nextcloud databse form backups.
    --dry-run                             Perform a trial run with no changes made.


Exit status:
 0  if OK,
 1  if minor problems (e.g., some important variables are not set),
 2  if serious trouble (e.g., cannot perform the backup).
EOF
}

function trim {
    $ECHO $1 | $SED 's/^-*//'
}

function report_error {
    error_message="Error: $@"
    stderr=""
    if [[ -z "$SILENT" || "$SILENT" = false ]]; then
       stderr="--stderr"
    fi
    $LOGGER $stderr $error_message
}

function check_option_called {
    values=$($ECHO $@ | $CUT -d " " -f2- | $SED 's/[ ]*//g')
    option_called="_OPTION_CALLED"
    option_name=$( $ECHO $@ | $CUT -d " " -f1 )
    variable_name=$($ECHO $option_name | $TR '[:lower:]' '[:upper:]' | $TR '-' '_')
    variable_called_name="$variable_name$option_called"
    if [[ -z ${!variable_called_name} || "${!variable_called_name}" = false  ]]; then
        if [ "$#" -eq 1 ]; then
            eval $variable_name=true
        fi
        if [ "$#" -gt 1 ]; then
            eval $variable_name=$values
            if [ -z "$variable_name" ]; then
                error_msg="$variable_name was supposed to be set. Can't parse '$2'."
                report_error $error_msg
                exit 1
            fi
        fi
        eval $variable_called_name=true
    else
        error_msg="It is not allowed to set $option_name options more than two times."
        report_error $error_msg
        exit 1
    fi
}

function get_option_from_short_options_array {
    arg=$(trim $1)
    result=${short_options_array[$arg]}
    check_option_called $result
}

function get_option_from_short_options_hash {
    arg=$(trim $1)
    result=${short_options_hash[$arg]}
    check_option_called $result
}

function variables_to_test {
    variables_to_test=$($ECHO $1 | $SED 's/,/ /g' | $TR '[:lower:]' '[:upper:]' | $TR '-' '_' )
    for var in $variables_to_test
    do
        if [[ -z ${!var} ]]; then
            $ECHO "$var is not defined"
        else
            $ECHO "$var -> ${!var}"
        fi
    done
}


# Options
declare -A short_options_array=(
   ["h"]="help"
)

#Because of the eval below, --help option can't exist
short_options_array_list=$( $ECHO "${!short_options_array[@]}" | $SED 's/ //g' )
short_options_array_OR=$( $ECHO "${!short_options_array[@]}" | $SED 's/\([^ ]\)/-\1 |/g' | $SED 's/|$//g' )

declare -A short_options_hash=(
    ["v"]="verbose"
    ["s"]="silent"
    ["u"]="usage"
    ["l"]="enable-log"
)
short_options=$( $ECHO "${!short_options_hash[@]}" | $SED 's/ //g' )
short_options_OR=$( $ECHO "${!short_options_hash[@]}" | $SED 's/\([^ ]\)/-\1 |/g' | $SED 's/|$//g' )

of_short=$(for KEY in "${!short_options_hash[@]}"; do $PRINTF "${short_options_hash[$KEY]},"; done )
of_short_OR=$(for KEY in "${!short_options_hash[@]}"; do $PRINTF "--${short_options_hash[$KEY]} | "; done | $SED 's/| $//g' )

declare -a long_options_with_no_params_array
long_options_with_no_params_array=(
    'exclude-database'
    'dry-run'
)
no_params=$( $ECHO ${long_options_with_no_params_array[@]} | $SED 's/ /,/g' | $SED 's/$/,/g' )
no_params_OR=$( $ECHO ${long_options_with_no_params_array[@]} | $SED 's/\([^ ]*\)/--\1 |/g' | $SED 's/|$//g' )

declare -a long_options_with_one_param_array
long_options_with_one_params_array=(
    's3-access-key'
    's3-secret-key'
    'database-name'
    'database-user'
    'database-passwd'
    'database-host'
    'database-port'
    'nextcloud-path'
    'nextcloud-users'
    'log-file'
    'test'
)
one_param=$( $ECHO ${long_options_with_one_params_array[@]} | $SED 's/ /:,/g' | $SED 's/$/:,/g' )
one_param_OR=$( $ECHO ${long_options_with_one_params_array[@]} | $SED 's/\([^ ]*\)/--\1 |/g' | $SED 's/|$//g' )

OPTS=`getopt -o $short_options_array_list$short_options --long $no_params$of_short$one_param -n 'parse-options' -- "$@" 2> .error.log `

if [ $? -ne 0 ]; then
    error_msg=$($CAT .error.log)
    report_error $error_msg
    $RM .error.log
    exit 1
fi
$RM .error.log

eval set -- "$OPTS"

while true; do
  eval "
  case \"$1\" in
    $short_options_array_OR )
            get_option_from_short_options_array $1
            shift ;;
    $short_options_OR )
            get_option_from_short_options_hash $1
            shift ;;
    $of_short_OR )
            check_option_called $( trim $1 )
            shift ;;
    $no_params_OR )
            check_option_called $( trim $1 )
            shift ;;
    $one_param_OR )
            check_option_called $( trim $1 ) $2
            shift ; shift;;
    -- ) shift; break ;;
    * ) break ;;
  esac"
done

# Look for tests
if [[ -n $TEST ]]; then
    variables_to_test $TEST
    exit 0
fi

# If usage option is set stop the script and print usage
if [[ -n $USAGE || -n $HELP ]]; then
    usage
    exit 0
fi

# If there still arguments not handled abort this script
if [[ "$#" -ne 0 ]]; then
    error_msg="Found illegal parameters: $@"
    report_error $error_msg
    if [[ -z $SILENT  ]];then
        usage
    fi
    exit 1
fi

# Get variables from files

# If required, enable log
if [[ -n $ENABLE_LOG && -z $LOG_FILE ]];then
    error_msg="Log enabled but there is no log file declared, add '--log-file' option."
    report_error $error_msg
    exit 1
else
    # Check if folder is writable
    if [ -f "$LOG_FILE" ]; then
        if [[ ! -w "$LOG_FILE" ]];then
            error_msg="Cannot write log in '$LOG_FILE': Permission Denied"
            report_error $error_msg
            exit 1
        fi
    else
        folder=$( $ECHO $LOG_FILE | $SED 's|/[^/]*$||' )
        if [[ -w $folder ]]; then
            $TOUCH $LOG_FILE
        else
            if [[ -d $folder  ]]; then
                error_msg="Cannot write log in '$folder': Permission Denied"
                report_error $error_msg
                exit 1
            else
                error_msg="Cannot write log in '$folder': Given path does not exist"
                report_error $error_msg
                exit 1
            fi
        fi
    fi
fi

# Check if folder is writable
if [[ -n $ENABLE_LOG && -z $LOG_FILE ]];then
    error_msg="Log enabled but there is no log file declared, add '--log-file' option."
    report_error $error_msg
    exit 1
fi


exit 0
