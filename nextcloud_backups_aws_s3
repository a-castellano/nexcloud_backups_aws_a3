#!/bin/bash
#
# ** nextcloud_backups_aws_s3 **
# Utility to make backups of Nextcloud and store them in an S3 bucket
#
# √Ålvaro Castellano Vela - https://github.com/a-castellano

# Option variables
ENABLE_LOG=false # by default this script write logs via syslog

# Default values
if [[ -z $NEXTCLOUD_PATH ]]; then
    NEXTCLOUD_PATH='/var/www/nextcloud'
fi

if [[ -z $CONFIG_FILE  ]]; then
    CONFIG_FILE='~/.config/nextcloud_backups_aws_s3'
fi

# Nextcloud variables
NEXTCLOUD_CONFIG_ROUTE='/config/config.php'
NEXTCLOUD_USERS='ALL'

# Log variables
LOGGET_TAG="nextcloud_backups_aws_s3"
LOGGER="$(which logger) -t $LOGGET_TAG"

# Error file
LOCAL_ERROR_FILE='.error.log'

# Misc
WHICH=$(which which)
ECHO=$($WHICH echo)
TR=$($WHICH tr)
RM=$($WHICH rm)
SED=$($WHICH sed)
CAT=$($WHICH cat)
PRINTF=$($WHICH printf)
CUT=$($WHICH cut)
TOUCH=$($WHICH touch)
GREP=$($WHICH grep)

# Functions

function usage {
$CAT << EOF
Usage: nextcloud_backups_aws_s3 [OPTIONS] [ARGUMENTS]
Make backups of Nextcloud and store them in an S3 bucket.

For avoiding user to wirte thier secret credentials in the command line
this script will look for config variables in ~/.config/nextcloud_backups_aws_s3
folder. In that folder users can place a files or files contining their
database credentials, S3 access keys, etc.

Arguments:

    --s3-access-key=YOUR_S3_ACCES_KEY
    --s3-secret-key=YOUR_S3_SECRET_KEY
    --database-name=DATABASE_NAME
    --database-user=DATABASE_USER_NAME
    --database-passwd=DATABASE_PASSWORD
    --database-host=DATABSE_HOST           (IP or domain)
    --database-port=PORT                   By default it will be 3306.
    --config-file=PATH_TO_FILE             File containing script config
                                             by default it will be
                                             ~/.config/nextcloud_backups_aws_s3.
    --nextcloud-users="user1,user2"        By default this script will backup
                                             all users folders.
    --nextcloud-path=PATH                  Nexcloud path is /var/www/nextcloud
                                             by default.
    --test="argument,argument2"            Prints valuw of selected arguments.

    Nexcloud users and test varibales can be separated by spaces

Options:

    -h                                    Prints this text.
    -u --usage                            Prints this text.
    -v --verbose                          Enables verbose output.
    -s --silent                           Disable any output in STDOUT.
    -l --enable-log                       By default this scripts uses syslog
                                            for logging with this option enables
                                            it also write logs in the file
                                            spefied in "--logfile" option.
    --log-file=FILE                       In addition to write logs in syslog the
                                            logs will be written in the file provided.
    --exclude-database                    Exclude Nextcloud databse form backups.
    --dry-run                             Perform a trial run with no changes made.


Exit status:
 0  if OK,
 1  if minor problems (e.g., some important variables are not set),
 2  if serious trouble (e.g., cannot perform the backup).
EOF
}

function trim {
    $ECHO $1 | $SED 's/^-*//'
}

function report_error {
    error_message="Error: $@"
    stderr=""
    if [[ -z "$SILENT" || "$SILENT" = false ]]; then
       stderr="--stderr"
    fi
    $LOGGER $stderr $error_message
}

function check_option_called {
    values=$( $ECHO $@ | $CUT -d " " -f2- | $SED 's/[ ]*//g' )
    option_called="_OPTION_CALLED"
    option_name=$( $ECHO $@ | $CUT -d " " -f1 )
    variable_name=$( $ECHO $option_name | $TR '[:lower:]' '[:upper:]' | $TR '-' '_' )
    variable_called_name="$variable_name$option_called"
    if [[ -z ${!variable_called_name} || "${!variable_called_name}" = false  ]]; then
        if [ "$#" -eq 1 ]; then
            eval $variable_name=true
        fi
        if [ "$#" -gt 1 ]; then
            eval $variable_name=$values
            if [ -z "$variable_name" ]; then
                error_msg="$variable_name was supposed to be set. Can't parse '$2'."
                report_error $error_msg
                exit 1
            fi
        fi
        eval $variable_called_name=true
    else
        error_msg="It is not allowed to set $option_name options more than two times."
        report_error $error_msg
        exit 1
    fi
}

function get_option_from_short_options_array {
    arg=$(trim $1)
    result=${short_options_array[$arg]}
    check_option_called $result
}

function get_option_from_short_options_hash {
    arg=$( trim $1 )
    result=${short_options_hash[$arg]}
    check_option_called $result
}

function variables_to_test {
    variables_to_test=$( $ECHO $1 | $SED 's/,/ /g' | $TR '[:lower:]' '[:upper:]' | $TR '-' '_' )
    for var in $variables_to_test
    do
        if [[ -z ${!var} ]]; then
            $ECHO "$var is not defined"
        else
            $ECHO "$var -> ${!var}"
        fi
    done
}

function test_config_file {
    file=$1

    if [[ ! -f $file ]]; then
        error_msg="Config file '$file' does not exist."
        report_error $error_msg
        exit 1
    fi
    if [[ ! -w $file ]]; then
        error_msg="Can't write '$file', permission denied."
        report_error $error_msg
        exit 1
    fi
}

function get_variables_config_file {

    test_config_file $CONFIG_FILE

    declare -a config_variables
    config_variables=(
        'S3_ACCESS_KEY'
        'S3_SECRET_KEY'
        'DATABASE_NAME'
        'DATABASE_PASSWD'
        'DATABASE_PORT'
        'DATABASE_USER'
        'DATABASE_HOST'
        'NEXTCLOUD_USERS'
        'LOG_FILE'
    )

    for var in "${config_variables[@]}"
    do
        if [[ -z ${!var}  ]]; then
            value=$( $GREP $var $CONFIG_FILE | $SED "s|$var[ ]*=[ ]*||")
            if [[ ! "$value" = "" ]]; then
                eval $var=$value
            fi
        fi
    done

}


function get_variables_from_nextcloud_config_file {

    nextcloud_config_file=$NEXTCLOUD_PATH$NEXTCLOUD_CONFIG_ROUTE
    test_config_file $nextcloud_config_file

    declare -A variables_to_nextcloud_variables=(
        ["DATABASE_NAME"]="dbname"
        ["DATABASE_HOST"]="dbhost"
        ["DATABASE_PORT"]="dbport"
        ["DATABASE_USER"]="dbuser"
        ["DATABASE_PASSWD"]="dbpassword"
    )

    for var in "${!variables_to_nextcloud_variables[@]}"
    do
        if [[ -z ${!var}  ]]; then
            value=$( $GREP ${variables_to_nextcloud_variables[$var]} $nextcloud_config_file | $SED "s/^.* => '//" | $SED "s/',$//" )
            if [[ ! "$value" = "" ]]; then
                eval $var=$value
            fi
        fi
    done
}

function check_required_software {
    errors=false

    MYSQL=$($WHICH mysql)
    if [[ -z $MYSQL ]]; then
        errors=true
        error_msg="MySQL client is not installed, please install it before start backup jobs"
        report_error $error_msg
    fi
    MYDUMPER=$($WHICH mydumper)
    if [[ -z $MYDUMPER ]]; then
        errors=true
        error_msg="mydumper is not installed, please install it before start backup jobs"
        report_error $error_msg
    fi
    S3CMD=$($WHICH s3cmd)
    if [[ -z $S3CMD ]]; then
        errors=true
        error_msg="s3cmd is not installed, please install it before start backup jobs"
        report_error $error_msg
    fi

    if [[ "$errors" = "true" ]]; then
        exit 1
    fi
}

function check_databse_connection {
    TEST=$( mysql -u$DATABASE_USER -p$DATABASE_PASSWD --port=$DATABASE_PORT -h $DATABASE_HOST -Bse "use $DATABASE_NAME" 2> $LOCAL_ERROR_FILE > /dev/null )
    if [ $? -ne 0 ]; then
        error_msg=$( $CAT $LOCAL_ERROR_FILE )
        report_error $error_msg
        $RM $LOCAL_ERROR_FILE
        exit 1
    fi
    $RM .error.log
}

function check_s3_conection {
    exit 0
}

# Options
declare -A short_options_array=(
   ["h"]="help"
)

#Because of the eval below, --help option can't exist
short_options_array_list=$( $ECHO "${!short_options_array[@]}" | $SED 's/ //g' )
short_options_array_OR=$( $ECHO "${!short_options_array[@]}" | $SED 's/\([^ ]\)/-\1 |/g' | $SED 's/|$//g' )

declare -A short_options_hash=(
    ["v"]="verbose"
    ["s"]="silent"
    ["u"]="usage"
    ["l"]="enable-log"
)
short_options=$( $ECHO "${!short_options_hash[@]}" | $SED 's/ //g' )
short_options_OR=$( $ECHO "${!short_options_hash[@]}" | $SED 's/\([^ ]\)/-\1 |/g' | $SED 's/|$//g' )

of_short=$(for KEY in "${!short_options_hash[@]}"; do $PRINTF "${short_options_hash[$KEY]},"; done )
of_short_OR=$(for KEY in "${!short_options_hash[@]}"; do $PRINTF "--${short_options_hash[$KEY]} | "; done | $SED 's/| $//g' )

declare -a long_options_with_no_params_array
long_options_with_no_params_array=(
    'exclude-database'
    'dry-run'
)
no_params=$( $ECHO ${long_options_with_no_params_array[@]} | $SED 's/ /,/g' | $SED 's/$/,/g' )
no_params_OR=$( $ECHO ${long_options_with_no_params_array[@]} | $SED 's/\([^ ]*\)/--\1 |/g' | $SED 's/|$//g' )

declare -a long_options_with_one_param_array
long_options_with_one_params_array=(
    's3-access-key'
    's3-secret-key'
    's3-bucket'
    'database-name'
    'database-user'
    'database-passwd'
    'database-host'
    'database-port'
    'nextcloud-path'
    'nextcloud-users'
    'log-file'
    'config-file'
    'test'
)
one_param=$( $ECHO ${long_options_with_one_params_array[@]} | $SED 's/ /:,/g' | $SED 's/$/:,/g' )
one_param_OR=$( $ECHO ${long_options_with_one_params_array[@]} | $SED 's/\([^ ]*\)/--\1 |/g' | $SED 's/|$//g' )

OPTS=`getopt -o $short_options_array_list$short_options --long $no_params$of_short$one_param -n 'parse-options' -- "$@" 2> $LOCAL_ERROR_FILE `

if [ $? -ne 0 ]; then
    error_msg=$( $CAT $LOCAL_ERROR_FILE )
    report_error $error_msg
    $RM $LOCAL_ERROR_FILE
    exit 1
fi
$RM $LOCAL_ERROR_FILE

eval set -- "$OPTS"

while true; do
  eval "
  case \"$1\" in
    $short_options_array_OR )
            get_option_from_short_options_array $1
            shift ;;
    $short_options_OR )
            get_option_from_short_options_hash $1
            shift ;;
    $of_short_OR )
            check_option_called $( trim $1 )
            shift ;;
    $no_params_OR )
            check_option_called $( trim $1 )
            shift ;;
    $one_param_OR )
            check_option_called $( trim $1 ) $2
            shift ; shift;;
    -- ) shift; break ;;
    * ) break ;;
  esac"
done

# Get variables from files
get_variables_config_file
get_variables_from_nextcloud_config_file

# Check databse port

if [[ -z $DATABASE_PORT ]]; then
    DATABASE_PORT=3306
fi

if [[ -z $DATABASE_HOST ]]; then
    DATABASE_HOST="localhost"
fi

# Look for tests
if [[ -n $TEST ]]; then
    variables_to_test $TEST
    exit 0
fi

# If usage option is set stop the script and print usage
if [[ -n $USAGE || -n $HELP ]]; then
    usage
    exit 0
fi

# If there still arguments not handled abort this script
if [[ "$#" -ne 0 ]]; then
    error_msg="Found illegal parameters: $@"
    report_error $error_msg
    if [[ -z $SILENT  ]];then
        usage
    fi
    exit 1
fi

# Check if loggins into external file is enabled
if [[ "$ENABLE_LOG" = true ]]; then
    if [[ "$ENABLE_LOG" = true && -z $LOG_FILE ]];then
        error_msg="Log enabled but there is no log file declared, add '--log-file' option."
        report_error $error_msg
        exit 1
    else
        # Check if folder is writable
        if [ -f "$LOG_FILE" ]; then
            if [[ ! -w "$LOG_FILE" ]];then
                error_msg="Cannot write log in '$LOG_FILE': Permission Denied"
                report_error $error_msg
                exit 1
            fi
        else
            folder=$( $ECHO $LOG_FILE | $SED 's|/[^/]*$||' )
            if [[ -w $folder ]]; then
                $TOUCH $LOG_FILE
            else
                if [[ -d $folder  ]]; then
                    error_msg="Cannot write log in '$folder': Permission Denied"
                    report_error $error_msg
                    exit 1
                else
                    error_msg="Cannot write log in '$folder': Given path does not exist"
                    report_error $error_msg
                    exit 1
                fi
            fi
        fi
    fi
fi

# Check if all variables are set

declare -a required_variables
required_variables=(
    's3-access-key'
    's3-secret-key'
    's3-bucket'
    'database-name'
    'database-user'
    'database-passwd'
    'database-host'
    'database-port'
    'nextcloud-path'
    'nextcloud-users'
)

unset_variables=""
for var in ${required_variables[@]}
do
    variable=$($ECHO $var | $TR '[:lower:]' '[:upper:]' | $TR '-' '_' )
    if [[ -z ${!variable} ]]; then
        unset_variables="$unset_variables, $var"
    fi
done
if [[ ! "$unset_variables" = "" ]]; then
    unset_variables=$($ECHO $unset_variables | $SED 's/,//' )
    error_msg="The following variables has to have value: $unset_variables. Please set a valid value for it."
    report_error $error_msg
    usage
    exit 1
fi

# Check installed software
check_required_software

# Check database conection

check_databse_connection

exit 0
